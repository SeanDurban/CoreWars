!dead || forever

  acquire the core

  get curI from index mvar

  get curInstr at curI from core

  execute curInstr updating the core

  released the core

  Get newIndex of prog and update index MVar

  sleepthread() avoid starvation


  execution of instr

  DAT - Attempt to execute a DAT causes prog to halt
  *Will need some mechanism to stop execution here and make parent thread aware*

  MOV - Field A (val/instr to mov) and B (addr to move to)
    if fieldA Immed
      create a DAT at addrB with valFieldA
      update bIndex core (CoreAddr DAT Field Immed valFieldA Field Empty)
    else
      aIndex = applyAddrMode fieldA
      bIndex = applyAddrMode fieldB
      update bIndex core (index core aIndex)


 If you add two instructions together, both the A- and the B-fields will be added together independently of each other.
 If you add a single number to an instruction, it will by default be added to the B-field.
 It's quite possible to use a # in the B-field of the ADD too. Then the A-field would be added to the B-field of the ADD itself.
  ADD - field A and B
    if fieldA Immed fieldAVal
      bIndex = applyAddrMode fieldB curI
      bCoreAddr = index core bIndex
      newBCoreAddr = updateCoreVal ADD bCoreAddr 0 fieldAVal *MOD
      update bIndex core (index core bIndex )
    else
      aIndex = applyAddrMode fieldA
      bIndex = applyAddrMode fieldB
      --These are field values for coreAddr at aIndex
      fieldAVal = extractAVal (index core aIndex)
      fieldBVal = extractBVal (index core aIndex)
      newBCoreAddr = updateCoreVal ADD bCoreAddr fieldAVal fieldBVal *MOD
      update bIndex core (index core bIndex )


  SUB - similar to above



  JMP - only has A fieldA
    Does nothing to core so just return same core2

  JMZ / JMN / DJN - nothing to core just updates curProg index so handled through that


  CMP is the same


  SPL wont be implemented till end
   => may require additional forking and could be tricky for MVAR
